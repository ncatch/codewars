// https://www.codewars.com/kata/5ec9e176721b990029ebce83/train/javascript

class Image {
	constructor(w, h, data) {
		this.pixels = data.slice();
		this.width = w;
		this.height = h;
	}
}

let image = new Image(13, 18, [
	0xff, 0xff, 0xff, 0xc0, 0xad, 0xad, 0xad, 0xad, 0xaf, 0xe8, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xda, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0x28, 0x2e, 0xe, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xd4, 0x0, 0x0, 0xdc, 0xff, 0x50, 0x0, 0x37, 0xff, 0xff, 0xff,
	0xff, 0xd3, 0x42, 0x0, 0x0, 0x3a, 0x44, 0x12, 0x0, 0xe, 0x81, 0xf3, 0xff,
	0xd9, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0xff,
	0xb0, 0x0, 0xb, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x35, 0x0, 0xa, 0xf1,
	0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
	0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
	0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
	0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
	0xad, 0x0, 0x2b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x0, 0x0, 0xe8,
	0xb2, 0x0, 0x8, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x28, 0x0, 0xe, 0xf5,
	0xe8, 0x1e, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x6b, 0xff
]);

/**
 * 根据坐标获取像素
 * @param {Number} x X 坐标 从0开始
 * @param {Number} y Y 坐标 从0开始
 * @returns Number
 */
Image.prototype.getPixelByXY = function (x, y) {
	return this.pixels[this.width * y + x];
}

/**
 * 切割数字
 * @returns Array
 */
Image.prototype.getNumbers = function () {
	let startX = -1;
	const numbers = [];

	// 拆分数字
	for (let x = 0; x < this.width; x++) {
		let isEnd = true;

		for (let y = 0; y < this.height; y++) {
			const pixel = this.getPixelByXY(x, y);

			if (pixel == 0) {
				isEnd = false;

				// 第一次出现黑色 记为开始位置
				if (startX < 0) {
					startX = x;
				}
			}
		}

		// 一个数字结束  重新开始找下一个数字
		if (isEnd && startX >= 0 && startX != x) {
			numbers.push({
				sX: startX,
				eX: x,
			})

			startX = -1;
		}
	}

	return numbers;
}

/**
 * 去除上下空白
 * @param {Array} arr 
 * @returns Array
 */
function rmTupperAndLower(arr) {
	return arr.map(ele => {
		let y = 0;

		ele.sY = -1;

		for (; y < image.height; y++) {
			let isEnd = true;

			for (let x = ele.sX; x <= ele.eX; x++) {
				if (image.getPixelByXY(x, y) == 0) {
					isEnd = false;

					// 第一次出现黑色 记为开始位置
					if (ele.sY < 0) {
						ele.sY = y;
					}
				}
			}

			// 数字结束
			if (isEnd && ele.sY >= 0 && ele.sY != y) {
				ele.eY = y;

				return ele;
			}
		}

		ele.eY = y;
		return ele;
	})
}

function ocr(image) {
	// 找到阈值
	const effective = image.pixels.filter(ele => ele != 0 && ele != 255)
	const avg = effective.reduce((a, b) => a + b) / effective.length;

	// 二值化
	image.pixels = image.pixels.map(ele => ele <= avg ? 0 : 255);

	// 画出image
	// drawImage('#canvas', image);

	// 切割
	let numbers = image.getNumbers();

	// 去除上下空白
	// numbers = rmTupperAndLower(numbers);

	// 对比
	numbers.forEach(ele => {
		// 横向

		// 纵向
	})
}

console.log(ocr(image));